<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9067024774549867"
      crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ã€Šä¹±ä¸–è‹±è±ªå½•ï¼šä¸‰å›½ç¯‡ã€‹æ˜¯ä¸€ä¸ªç”±AIé©±åŠ¨çš„æ–‡å­—ç­–ç•¥æ²™ç›’æ¸¸æˆã€‚åœ¨è¿™é‡Œï¼Œä½ å¯ä»¥ä½“éªŒä»ä¸€ä»‹å¸ƒè¡£åˆ°ç§°éœ¸å¤©ä¸‹çš„å®Œæ•´ä¸‰å›½å¾ç¨‹ï¼Œæ¢ç´¢å¹¿è¢¤çš„ä¸­åå¤§åœ°ï¼Œåšå‡ºä½ çš„é€‰æ‹©ï¼Œä¹¦å†™ä½ çš„ä¼ å¥‡ã€‚">
    <meta name="keywords" content="ä¸‰å›½, æ–‡å­—æ¸¸æˆ, ç­–ç•¥, MUD, AI, æ²™ç›’, ä¹±ä¸–, è§’è‰²æ‰®æ¼”, RPG, äº’åŠ¨æ¼”ä¹‰">
    <meta name="author" content="AIæ²™ç›’ä¸–ç•Œ">

    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ai-game.jkai.de/">
    <meta property="og:title" content="ä¹±ä¸–è‹±è±ªå½•ï¼šä¸‰å›½ç¯‡ - AIé©±åŠ¨çš„æ²™ç›’ç­–ç•¥æ¼”ä¹‰">
    <meta property="og:description" content="ç½®èº«ä¸‰å›½ä¹±ä¸–ï¼Œä»ç±ç±æ— ååˆ°ä¸€ç»Ÿå¤©ä¸‹ï¼Œä½ çš„æ¯ä¸€æ­¥è°‹ç•¥éƒ½å°†é“¸å°±ç‹¬ä¸€æ— äºŒçš„éœ¸ä¸šã€‚">
    <meta property="og:image" content="https://ai-game.jkai.de/preview-image.jpg">

    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ai-game.jkai.de/">
    <meta property="twitter:title" content="ä¹±ä¸–è‹±è±ªå½•ï¼šä¸‰å›½ç¯‡ - AIé©±åŠ¨çš„æ²™ç›’ç­–ç•¥æ¼”ä¹‰">
    <meta property="twitter:description" content="ç½®èº«ä¸‰å›½ä¹±ä¸–ï¼Œä»ç±ç±æ— ååˆ°ä¸€ç»Ÿå¤©ä¸‹ï¼Œä½ çš„æ¯ä¸€æ­¥è°‹ç•¥éƒ½å°†é“¸å°±ç‹¬ä¸€æ— äºŒçš„éœ¸ä¸šã€‚">
    <meta property="twitter:image" content="https://ai-game.jkai.de/preview-image.jpg">
    <title>ä¹±ä¸–è‹±è±ªå½•ï¼šä¸‰å›½ç¯‡ - AIæ²™ç›’ä¸–ç•Œ</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --panda-color: #4ECDC4;
            --mushroom-color: #FF6B6B;
            --coriander-color: #06D6A0;
            --dark-bg: #1A1A2E;
            --darker-bg: #0D0D1A;
            --light-text: #F7F9F9;
            --pixel-border: #4ECDC4;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Press Start 2P', 'Courier New', monospace;
        }
        
        body {
            background: var(--dark-bg);
            color: var(--light-text);
            min-height: 100vh;
            padding: 20px;
            background-image: 
                radial-gradient(circle at 10% 20%, rgba(78, 205, 196, 0.1) 0%, transparent 20%),
                radial-gradient(circle at 90% 80%, rgba(255, 107, 107, 0.1) 0%, transparent 20%);
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            min-height: 95vh;
        }
        
        header {
            text-align: center;
            padding: 20px;
            margin-bottom: 20px;
            position: relative;
            border-bottom: 4px dotted var(--pixel-border);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
            color: var(--panda-color);
            text-shadow: 3px 3px 0 var(--mushroom-color), 
                         6px 6px 0 var(--coriander-color);
            letter-spacing: 2px;
            line-height: 1.3;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: var(--pixel-border);
            margin-bottom: 15px;
        }
        
        .game-ui {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 20px;
            flex: 1;
        }
        
        .game-area {
            background: rgba(13, 13, 26, 0.8);
            border: 4px solid var(--pixel-border);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
        }
        
        .scene-container {
            position: relative;
            min-height: 300px;
            margin-bottom: 20px;
            border: 3px solid var(--pixel-border);
            border-radius: 5px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        #scene-img {
            max-width: 100%;
            max-height: 280px;
            border-radius: 4px;
            image-rendering: pixelated;
        }
        
        .story-text {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--pixel-border);
            border-radius: 5px;
            padding: 20px;
            margin-bottom: 20px;
            font-size: 1.1rem;
            line-height: 1.6;
            min-height: 150px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.7);
            overflow-y: auto; /* Allow scrolling for long texts */
        }
        
        .choices-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px; /* Space before new input */
        }
        
        .choice-btn {
            background: linear-gradient(145deg, #2a2a4a, #1f1f3a);
            border: 3px solid var(--pixel-border);
            color: var(--light-text);
            padding: 15px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            position: relative;
            overflow: hidden;
        }
        
        .choice-btn:hover {
            background: linear-gradient(145deg, #3a3a5a, #2f2f4a);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        
        .choice-btn:active {
            transform: translateY(1px);
        }
        
        .choice-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.2),
                transparent
            );
            transition: 0.5s;
        }
        
        .choice-btn:hover::before {
            left: 100%;
        }
        
        .action-input-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }

        #player-input {
            width: 100%;
            min-height: 80px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid var(--pixel-border);
            border-radius: 5px;
            color: var(--light-text);
            font-family: 'Courier New', monospace;
            font-size: 1rem;
            resize: vertical;
        }

        #submit-action-btn {
            background: var(--coriander-color);
            border: 3px solid var(--coriander-color);
            color: var(--darker-bg);
            padding: 12px 20px;
            border-radius: 5px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: bold;
        }

        #submit-action-btn:hover {
            background: #05C18F;
            border-color: #05C18F;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .skill-btn {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }
        
        .stats-panel {
            background: rgba(13, 13, 26, 0.8);
            border: 4px solid var(--pixel-border);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .panel-title {
            font-size: 1.4rem;
            color: var(--pixel-border);
            text-align: center;
            margin-bottom: 15px;
            border-bottom: 2px dotted var(--pixel-border);
            padding-bottom: 10px;
        }
        
        .character-info {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 5px;
            padding: 15px;
            border: 2px solid var(--panda-color);
        }
        
        .char-header {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        .char-icon {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--panda-color);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            flex-shrink: 0;
        }
        
        .char-name {
            font-size: 1.4rem;
            color: var(--panda-color);
        }
        
        .health-bar {
            height: 20px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--panda-color), #ff8e8e);
            border-radius: 10px;
            transition: width 0.5s ease;
        }
        
        .health-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 1.4rem;
            color: var(--pixel-border);
        }
        
        .skills-container, .inventory-container, .achievement-container, .adventure-log-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 5px;
            padding: 15px;
        }

        .scrollable-content {
            max-height: 150px;
            overflow-y: auto;
            padding-right: 10px; /* for scrollbar */
        }
        
        .skills-container { border: 2px solid var(--mushroom-color); }
        .inventory-container { border: 2px solid var(--coriander-color); }
        .achievement-container { border: 2px solid gold; }
        .adventure-log-container { border: 2px solid var(--pixel-border); }
        
        .skill-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .skill-item {
            background: rgba(106, 13, 173, 0.3);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 5px;
            border-left: 4px solid var(--mushroom-color);
        }
        
        .skill-name {
            color: var(--mushroom-color);
            margin-bottom: 3px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: bold;
        }
        
        .skill-description {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.85rem;
            line-height: 1.3;
        }
        
        .items-grid {
            display: block;
            margin-top: 10px;
        }

        .item-text, .achievement-text {
            padding: 2px 5px;
            text-align: left;
            width: 100%;
        }
        
        .pixel-corner {
            position: absolute;
            width: 20px;
            height: 20px;
        }
        
        .pixel-corner.tl { top: 0; left: 0; border-top: 4px solid var(--pixel-border); border-left: 4px solid var(--pixel-border); }
        .pixel-corner.tr { top: 0; right: 0; border-top: 4px solid var(--pixel-border); border-right: 4px solid var(--pixel-border); }
        .pixel-corner.bl { bottom: 0; left: 0; border-bottom: 4px solid var(--pixel-border); border-left: 4px solid var(--pixel-border); }
        .pixel-corner.br { bottom: 0; right: 0; border-bottom: 4px solid var(--pixel-border); border-right: 4px solid var(--pixel-border); }
        
        .status-bar {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 5px;
            border: 2px solid var(--pixel-border);
        }
        
        .status-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .status-value {
            font-size: 1.4rem;
            color: var(--pixel-border);
        }
        
        .loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }
        
        .loading.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(78, 205, 196, 0.3);
            border-top: 5px solid var(--pixel-border);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .loading-text {
            font-size: 1.2rem;
            color: var(--pixel-border);
            text-align: center;
        }
        
        footer {
            text-align: center;
            padding: 20px;
            margin-top: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            border-top: 2px dotted var(--pixel-border);
        }
        
        @media (max-width: 768px) {
            .game-ui { grid-template-columns: 1fr; }
            h1 { font-size: 2rem; }
            .choices-container { grid-template-columns: 1fr; }
            
            .game-controls {
                flex-direction: column;
                gap: 10px;
                margin: 15px 0;
                padding: 10px;
            }
            
            .control-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }
            
            .status-bar {
                flex-wrap: wrap;
                gap: 10px;
                justify-content: center;
            }
        }
        
        .api-settings-container {
            background: var(--darker-bg);
            padding: 20px;
            margin-top: 20px;
            border: 2px solid var(--pixel-border);
            border-radius: 8px;
            /* display: none; /* Hidden by default */
        }
        .api-settings-container.active {
            display: block; /* Show when active */
        }

        .api-settings {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr auto auto;
            gap: 15px;
            align-items: center;
        }
        .api-settings input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--pixel-border);
            color: var(--light-text);
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        .api-settings-select {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--pixel-border);
            color: var(--light-text);
            padding: 10px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            width: 100%;
            cursor: pointer;
        }
        .api-settings-select option {
            background: var(--darker-bg);
            color: var(--light-text);
        }
        .api-settings button {
             background: var(--pixel-border);
             color: var(--darker-bg);
             border: none;
             padding: 10px 15px;
             border-radius: 4px;
             cursor: pointer;
             font-weight: bold;
        }
        
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            padding: 15px;
            background: rgba(13, 13, 26, 0.6);
            border: 2px solid var(--pixel-border);
            border-radius: 8px;
        }
        
        .control-btn {
            background: linear-gradient(145deg, #2a2a4a, #1f1f3a);
            border: 2px solid var(--pixel-border);
            color: var(--light-text);
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Press Start 2P', 'Courier New', monospace;
            position: relative;
            overflow: hidden;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }
        
        .control-btn:active {
            transform: translateY(0);
        }
        
        .reset-btn:hover {
            border-color: var(--mushroom-color);
            background: linear-gradient(145deg, #4a2a2a, #3a1f1f);
        }
        
        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.1),
                transparent
            );
            transition: 0.5s;
        }
        
        .control-btn:hover::before {
            left: 100%;
        }
    </style>
</head>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DFX8DXLG3F"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-DFX8DXLG3F');
</script>
<body>
<div class="container">
    <header>
        <h1>ä¹±ä¸–è‹±è±ªå½•ï¼šä¸‰å›½ç¯‡</h1>
        <p class="subtitle">ä¸€ä¸ªç”±AIé©±åŠ¨çš„æ²™ç›’ç­–ç•¥æ¼”ä¹‰</p>
    </header>

    <div class="status-bar">
        <div class="status-item"><span>é“œé’±</span><span class="status-value">50</span></div>
        <div class="status-item"><span>å£°æœ›</span><span class="status-value">0</span></div>
        <div class="status-item"><span>èº«ä»½</span><span class="status-value">å¸ƒè¡£</span></div>
    </div>

    <div class="game-controls">
        <button id="reset-game-btn" class="control-btn reset-btn">ğŸ”„ é‡å¼€å±€åŠ¿</button>
        
    </div>

    <div class="game-ui">
        <div class="game-area">
            <div class="loading" id="loading">
                <div class="loading-spinner"></div>
                <div class="loading-text">æ­£åœ¨æ¨æ¼”æ–°çš„ä¹±ä¸–...</div>
            </div>
            <div class="scene-container">
                <img id="scene-img" src="" alt="åœºæ™¯å›¾ç‰‡">
            </div>
            <div class="story-text" id="story-text">
                ä½ ä»ä¸€ä¸ªæ‚ é•¿çš„æ¢¦å¢ƒä¸­æƒŠé†’ï¼Œæ˜¯é—»æ‰€æœªé—»çš„å–§åš£ä¸ç¹åã€‚ä½†çœ¼å‰ï¼Œå´æ˜¯ç®€é™‹çš„èŒ…å±‹ã€å¾®å¼±çš„æ²¹ç¯ã€‚çª—å¤–ï¼Œæˆ˜ç«æ¸è¿‘ï¼Œç‹¼çƒŸå››èµ·ï¼Œè¿œæ–¹å±±å³¦åœ¨æš®è‰²ä¸­å½±å½±ç»°ç»°ã€‚ä½ æ„è¯†åˆ°ï¼Œä½ æ¥åˆ°äº†ä¸€ä¸ªåä¸ºâ€œæ±‰æœ«ä¸‰å›½â€çš„ä¹±ä¸–ã€‚åœ¨è¿™é‡Œï¼Œæ— è®ºæ˜¯å¸ƒè¡£ç™¾å§“è¿˜æ˜¯è±ªæ°åå£«ï¼Œçš†å¯å‡­å€Ÿæ™ºè°‹ä¸æ­¦å‹‡ï¼Œé€é¹¿ä¸­åŸï¼Œé—®é¼å¤©ä¸‹ï¼Œå¼€åˆ›å±äºè‡ªå·±çš„ç››ä¸–ã€‚ä¸€ä¸ªç¥ç§˜çš„å£°éŸ³åœ¨ä½ è„‘æµ·ä¸­å›å“ï¼šâ€œæ­¤ä¹ƒå¤©å‘½æ‰€å½’ï¼Œäº¦æ˜¯æ±ä¹‹æŠ‰æ‹©ã€‚é€‰æ‹©ä½ çš„å‡ºèº«ï¼Œä¹¦å†™ä½ çš„ä¼ å¥‡å§ã€‚â€
            </div>
            <div class="choices-container" id="choices-container">
                <button class="choice-btn" data-choice="orphan">ğŸ“œ ä¹±ä¸–å­¤å„¿ï¼Œèº«ä¸–æµ®æ²‰</button>
                <button class="choice-btn" data-choice="farmer">ğŸŒ¾ ä¹¡é‡å†œå¤«ï¼ŒåŠ›è€•å¤©ä¸‹</button>
                <button class="choice-btn" data-choice="scholar">ğŸ“š è½é­„å£«äººï¼Œæ»¡è…¹ç»çº¶</button>
                <button class="choice-btn" data-choice="merchant">ğŸ’° è¡Œå•†ä¹‹å­ï¼Œè´¢è¿äº¨é€š</button>
            </div>
        </div>
        <div class="stats-panel">
            <h2 class="panel-title">è§’è‰²çŠ¶æ€</h2>
            <div class="character-info">
                <div class="char-header">
                    <div class="char-icon">ğŸ‘¤</div>
                    <div id="char-name" class="char-name">æ— åå°å’</div>
                </div>
                <div class="health-bar">
                    <div id="health-bar" class="health-fill"></div>
                    <div id="health-text" class="health-text">ä½“åŠ›: 100/100</div>
                </div>
                <div class="stats-grid">
                    <div class="stat-item"><span>æ­¦åŠ›</span><span id="attack-value" class="stat-value">5</span></div>
                    <div class="stat-item"><span>æ™ºåŠ›</span><span id="defense-value" class="stat-value">5</span></div>
                    <div class="stat-item"><span>ç»Ÿç‡</span><span id="agility-value" class="stat-value">5</span></div>
                    <div class="stat-item"><span>é­…åŠ›</span><span id="charm-value" class="stat-value">5</span></div>
                </div>
            </div>
            <div class="skills-container">
                <h3 class="panel-title">æˆ˜æ³•/è®¡ç­–</h3>
                <div id="skills-list" class="scrollable-content"></div>
            </div>
            <div class="inventory-container">
                <h3 class="panel-title">è¡Œå›Š</h3>
                <div id="items-grid" class="scrollable-content"></div>
            </div>
            <div class="achievement-container">
                <h3 class="panel-title">åŠŸç»©</h3>
                <div id="achievement-list" class="scrollable-content"></div>
            </div>
            <div class="adventure-log-container">
                <h3 class="panel-title">å¤§äº‹è®°</h3>
                <div id="adventure-log" class="scrollable-content"></div>
            </div>
        </div>
    </div>

    <div class="api-settings-container" id="api-settings-container">
        <h3 class="panel-title">AIæ¨¡å‹è®¾ç½®</h3>
        <p id="api-settings-hint" style="font-size: 0.9rem; color: #888; margin-bottom: 15px;">
            ğŸ”’ é»˜è®¤ä½¿ç”¨å®‰å…¨çš„åç«¯APIï¼Œæ— éœ€é…ç½®ã€‚<br>
            å¦‚éœ€ä½¿ç”¨è‡ªå®šä¹‰APIï¼Œè¯·å¡«å†™ä»¥ä¸‹ä¿¡æ¯ï¼ˆé…ç½®ä»…å­˜äºå‰ç«¯æµè§ˆå™¨ï¼Œæ— éœ€æ‹…å¿ƒæ³„éœ²ï¼‰ï¼š
        </p>
        <div class="api-settings">
            <input type="text" id="api-url-input" placeholder="è‡ªå®šä¹‰API URL (å¯é€‰)">
            <select id="model-input" class="api-settings-select"></select>
            <input type="password" id="api-key-input" placeholder="è‡ªå®šä¹‰API Key (å¯é€‰)">
            <button id="save-api-btn">ä¿å­˜</button>
            <button id="clear-api-btn">æ¸…é™¤</button>
        </div>
    </div>

    <footer>
        ç”± AI é©±åŠ¨çš„æ–‡å­—ç­–ç•¥æ¸¸æˆ
    </footer>
</div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            faction: null,
            health: 100,
            maxHealth: 100,
            attack: 5,
            defense: 5,
            agility: 5,
            charm: 5,
            coins: 50,
            reputation: 0,
            level: 1, 
            skills: [
                {
                    name: "åŸºç¡€æ‹³æ³•",
                    description: "åŸºæœ¬æ­¦å­¦æ‹›å¼ï¼Œè¿‘èº«æˆ˜æ–—æ—¶å‘æŒ¥ä½œç”¨",
                    icon: "fa-solid fa-hand-fist"
                },
                {
                    name: "å‡ç¥é™æ°”",
                    description: "å†·é™å¿ƒæ€",
                    icon: "fa-solid fa-wind"
                }
            ],
            items: [],
			achievements: [
				// åŸºç¡€åŠŸç»©
				{ id: 'first_choice', text: 'åˆå…¥ä¹±ä¸–: åšå‡ºä½ çš„äººç”ŸæŠ‰æ‹©', unlocked: false },
				{ id: 'first_battle', text: 'åˆè¯•åˆ€å…µ: ç¬¬ä¸€æ¬¡äº²ä¸´æ²™åœº', unlocked: false },
				{ id: 'first_victory', text: 'é¦–æˆ˜å‘Šæ·: èµ¢å¾—ç¬¬ä¸€åœºå°è§„æ¨¡èƒœåˆ©', unlocked: false },
				{ id: 'breakthrough_qi', text: 'å´­éœ²å¤´è§’: åœ¨éƒ¡å¿ä¹¡é‡Œè·å¾—ä¸€å®šåå£°', unlocked: false },
				{ id: 'breakthrough_foundation', text: 'ä¸€æ–¹è±ªå¼º: æˆåŠŸå é¢†ä¸€å¿ä¹‹åœ°æˆ–èšæ‹¢ä¸€æ‰¹è¿½éšè€…', unlocked: false },

				// æ¢ç´¢ä¸æœºé‡
				{ id: 'found_hidden_cave', text: 'å¥‡é‡è¿­å‡º: å‘ç°ä¸€å¤„éšç§˜çš„æ´çªŸï¼Œå†…è—çç¨€å®ç‰©', unlocked: false }, 
				{ id: 'found_ancient_ruin', text: 'å¯»è®¿å¤è¿¹: æ·±å…¥äººè¿¹ç½•è‡³ä¹‹åœ°ï¼Œå‘ç°ä¸€å¤„è’åºŸçš„å¤æˆ˜åœºæˆ–å‰æœé—å€', unlocked: false },
				{ id: 'met_mysterious_master', text: 'ä¸‰é¡¾èŒ…åº: å‘ç°å¹¶æˆåŠŸæ‹›å‹Ÿåˆ°ä¸€ä½éšä¸–ä¸å‡ºçš„è´¤æ‰', unlocked: false }, 
				{ id: 'survive_miasma_swamp', text: 'åŒ–é™©ä¸ºå¤·: æˆåŠŸç©¿è¶Šå±æœºå››ä¼çš„å±±å²­æˆ–æ²¼æ³½åœ°å¸¦', unlocked: false },

				// è´¢å¯Œä¸èµ„å†
				{ id: 'first_spirit_treasure', text: 'å¾—é‡è‰¯é©¹: è·å¾—ä¸€åŒ¹åƒé‡Œé©¬æˆ–ä¸€ä»¶ç¨€ä¸–å…µå™¨', unlocked: false },
				{ id: 'rich_man', text: 'å¯Œå¯æ•Œå›½: èšæ‹¢å¤§é‡é’±ç²®ï¼Œè¶³ä»¥æ”¯æ’‘ä¸€æ”¯å†›é˜Ÿ', unlocked: false },
				{ id: 'master_alchemist', text: 'å†›éœ€å®˜: ç²¾é€šå†›å¤‡ç”Ÿäº§æˆ–ä¼¤è¯åˆ¶ä½œ', unlocked: false },
				{ id: 'spirit_stone_collector', text: 'å±¯ç”°èƒ½æ‰‹: æˆåŠŸå¼€å‘ä¸‰å¤„ä¸åŒç±»å‹çš„å¯Œé¥¶åœŸåœ°', unlocked: false },

				// æˆ˜æ–—ä¸ç­–ç•¥
				{ id: 'flawless_victory', text: 'å…µä¸è¡€åˆƒ: åœ¨ä¸æŸä¸€å…µä¸€å’çš„æƒ…å†µä¸‹èµ¢å¾—ä¸€åœºèƒœåˆ©', unlocked: false },
				{ id: 'slay_demon_beast', text: 'é˜µæ–©æ•Œå°†: åœ¨ä¸‡å†›ä¹‹ä¸­æ–©æ€æ•Œæ–¹ä¸»å°†', unlocked: false },
				{ id: 'master_of_spells', text: 'è¿ç­¹å¸·å¹„: æˆåŠŸç­–åˆ’å¹¶å®æ–½ä¸€é¡¹æ‰­è½¬æˆ˜å±€çš„è®¡è°‹', unlocked: false },
				{ id: 'survived_ambush', text: 'çªå‡ºé‡å›´: åœ¨æ•Œå†›çš„é‡é‡åŒ…å›´ä¸­å…¨èº«è€Œé€€', unlocked: false },
				{ id: 'first_skill', text: 'å­¦æœ‰æ‰€æˆ: æŒæ¡ä¸€é¡¹å®ç”¨çš„æ­¦è‰ºæˆ–æ²»å›½æ–¹ç•¥', unlocked: false },
				{ id: 'skill_master', text: 'ç™¾è‰ºç²¾é€š: æŒæ¡äº”ç§ä¸åŒçš„å†›æ”¿æˆ–æ°‘ç”ŸæŠ€èƒ½', unlocked: false },
				{ id: 'sword_master', text: 'ä¸‡äººæ•Œ: ä¸ªäººæ­¦è‰ºè¾¾åˆ°è¶…å‡¡å…¥åœ£çš„å¢ƒç•Œ', unlocked: false },
				{ id: 'spell_caster', text: 'å…µæ³•å¤§å®¶: ç²¾é€šã€Šå­™å­å…µæ³•ã€‹ç­‰å…µä¹¦ï¼Œèƒ½å¸ƒä¸‹ç²¾å¦™é˜µå‹', unlocked: false },

				// ç¤¾äº¤ä¸å£°æœ›
				{ id: 'high_reputation', text: 'å¨éœ‡ä¸€æ–¹: åœ¨éƒ¡å¿ä¹ƒè‡³å·åŸŸå†…å»ºç«‹å´‡é«˜å¨æœ›', unlocked: false },
				{ id: 'sect_elder', text: 'æ‹œå°†å…¥ç›¸: å—åˆ°ä¸€æ–¹è¯¸ä¾¯é‡ç”¨ï¼Œèº«å±…é«˜ä½', unlocked: false },
				{ id: 'dao_companion', text: 'å–œç»“è‰¯ç¼˜: ä¸ä¸€ä½ä¸–å®¶å¥³å­æˆ–è´¤è‰¯æ·‘å¥³ç»“ä¸ºè¿ç†', unlocked: false },
				{ id: 'peacemaker', text: 'ä»¥å¾·æœäºº: æˆåŠŸè°ƒè§£ä¸¤å¤§ä¸–å®¶æˆ–åœ°æ–¹åŠ¿åŠ›é—´çš„çº·äº‰', unlocked: false },

				// ç‰¹æ®Šä¸éšè—
				{ id: 'defy_heavenly_tribulation', text: 'åŠ›æŒ½ç‹‚æ¾œ: åœ¨å¤§å¦å°†å€¾ä¹‹é™…ï¼ŒåŠ›ä¿ç¤¾ç¨·ä¸å¤±', unlocked: false },
				{ id: 'ancient_bloodline', text: 'æ˜­çƒˆé—å¿—: ç»§æ‰¿æˆ–å…‰å¤äº†è¡°è½çš„æ±‰å®¤è¡€è„‰', unlocked: false },
				{ id: 'uncovered_conspiracy', text: 'æ‹¨ä¹±åæ­£: å‘ç°å¹¶ç“¦è§£äº†ä¸€ä¸ªé¢ è¦†æœçº²çš„å·¨å¤§é˜´è°‹', unlocked: false }
			],
            adventureLog: [],
            turn: 0,
            currentScene: "start"
        };

        // DOMå…ƒç´ 
        const storyText = document.getElementById('story-text');
        const choicesContainer = document.getElementById('choices-container');
        const sceneImg = document.getElementById('scene-img');
        const loadingOverlay = document.getElementById('loading');
        const charName = document.getElementById('char-name');
        const healthBar = document.getElementById('health-bar');
        const healthText = document.getElementById('health-text');
        const skillsList = document.getElementById('skills-list');
        const apiUrlInput = document.getElementById('api-url-input');
        const modelInput = document.getElementById('model-input');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiBtn = document.getElementById('save-api-btn');
        const clearApiBtn = document.getElementById('clear-api-btn');
        const coinsEl = document.querySelector('.status-bar .status-item:nth-child(1) .status-value');
        const reputationEl = document.querySelector('.status-bar .status-item:nth-child(2) .status-value');
        const levelEl = document.querySelector('.status-bar .status-item:nth-child(3) .status-value');
        const attackEl = document.getElementById('attack-value');
        const defenseEl = document.getElementById('defense-value');
        const agilityEl = document.getElementById('agility-value');
        const charmEl = document.getElementById('charm-value');
        const itemsGrid = document.getElementById('items-grid');
        const achievementList = document.getElementById('achievement-list');
        const adventureLogEl = document.getElementById('adventure-log');
        const apiSettingsContainer = document.getElementById('api-settings-container');
        const toggleApiSettingsBtn = document.getElementById('toggle-api-settings-btn');


        // ä¿å­˜æ¸¸æˆçŠ¶æ€
        function saveGameState() {
            try {
                // ä¿å­˜å½“å‰çš„é€‰æ‹©æŒ‰é’®
                const currentChoices = [];
                const choiceButtons = choicesContainer.querySelectorAll('.choice-btn');
                choiceButtons.forEach(btn => {
                    currentChoices.push({
                        text: btn.textContent,
                        target: btn.dataset.choice
                    });
                });

                const saveData = {
                    gameState: gameState,
                    currentStoryText: storyText.textContent,
                    currentSceneImg: sceneImg.src,
                    currentChoices: currentChoices,
                    saveTime: new Date().toISOString()
                };
                localStorage.setItem('cultivationGameSave', JSON.stringify(saveData));
                console.log('æ¸¸æˆçŠ¶æ€å·²ä¿å­˜');
                return true;
            } catch (error) {
                console.error('ä¿å­˜æ¸¸æˆçŠ¶æ€å¤±è´¥:', error);
                return false;
            }
        }

        // åŠ è½½æ¸¸æˆçŠ¶æ€
        function loadGameState() {
            try {
                const saveData = localStorage.getItem('cultivationGameSave');
                if (!saveData) return false;
                
                const parsed = JSON.parse(saveData);
                if (!parsed.gameState) return false;
                
                // Recover game state
                Object.assign(gameState, parsed.gameState);

                // Check if the game is over when loading
                if (gameState.health <= 0) {
                    updateUI();
                    storyText.textContent = "ä½ å€’åœ¨è¡€æ³Šä¹‹ä¸­ï¼Œæ„è¯†é€æ¸æ¨¡ç³Š... ä½ çš„å†’é™©å·²åœ¨æ­¤ç»ˆç»“ã€‚";
                    choicesContainer.innerHTML = '';
                    const restartBtn = document.createElement('button');
                    restartBtn.className = 'choice-btn';
                    restartBtn.textContent = 'ğŸ”„ é‡æ–°å¼€å§‹';
                    restartBtn.onclick = resetGame;
                    choicesContainer.appendChild(restartBtn);
                    choicesContainer.style.gridTemplateColumns = '1fr';
                    console.log('Loaded into game over state');
                    return true;
                }
                
                // Recover UI
                if (parsed.currentStoryText) {
                    storyText.textContent = parsed.currentStoryText;
                }
                if (parsed.currentSceneImg && parsed.currentSceneImg !== window.location.href && !parsed.currentSceneImg.includes('undefined') && !parsed.currentSceneImg.includes('file:///')) {
                    sceneImg.src = parsed.currentSceneImg;
                    sceneImg.style.opacity = 1;
                }
                
                // Recover choices buttons
                if (parsed.currentChoices && Array.isArray(parsed.currentChoices)) {
                    choicesContainer.innerHTML = '';
                    parsed.currentChoices.forEach(choice => {
                        const button = document.createElement('button');
                        button.className = 'choice-btn';
                        button.dataset.choice = choice.target;
                        button.textContent = choice.text;
                        choicesContainer.appendChild(button);
                    });
                }
                
                updateUI();
                console.log('æ¸¸æˆçŠ¶æ€å·²åŠ è½½ï¼Œä¿å­˜æ—¶é—´:', parsed.saveTime);
                return true;
            } catch (error) {
                console.error('åŠ è½½æ¸¸æˆçŠ¶æ€å¤±è´¥:', error);
                return false;
            }
        }

        // Reset Game
		async function resetGame() {
			if (confirm('ç¡®å®šè¦é‡å¼€ä¸€å±€å—ï¼Ÿè¿™å°†æ¸…é™¤æ‰€æœ‰è¿›åº¦ï¼Œæ— æ³•æ¢å¤ï¼Œå¤©ä¸‹å¤§åŠ¿å°†é‡æ–°æ¨æ¼”ï¼')) {
				// Clear saved game state
				localStorage.removeItem('cultivationGameSave');

				// Reset game state to initial values
				gameState.faction = null;
				gameState.health = 100;
				gameState.maxHealth = 100;
				gameState.attack = 5;
				gameState.defense = 5;
				gameState.agility = 5;
				gameState.charm = 5;
				gameState.coins = 50;
				gameState.reputation = 0;
				gameState.level = 1;
				gameState.skills = [];
				gameState.items = [];
				gameState.achievements.forEach(ach => ach.unlocked = false);
				gameState.adventureLog = [];
				gameState.turn = 0;
				gameState.currentScene = "start";

				// Reset UI to initial state
				storyText.textContent = 'ä½ ä»ä¸€ä¸ªæ‚ é•¿çš„æ¢¦å¢ƒä¸­æƒŠé†’ï¼Œæ¢¦é‡Œæ˜¯æœªæ¥ä¸–ç•Œçš„å¥‡å·§æ·«æŠ€ï¼Œæ˜¯é—»æ‰€æœªé—»çš„å–§åš£ä¸ç¹åã€‚ä½†çœ¼å‰ï¼Œå´æ˜¯ç®€é™‹çš„èŒ…å±‹ã€å¾®å¼±çš„æ²¹ç¯ã€‚çª—å¤–ï¼Œæˆ˜ç«æ¸è¿‘ï¼Œç‹¼çƒŸå››èµ·ï¼Œè¿œæ–¹å±±å³¦åœ¨æš®è‰²ä¸­å½±å½±ç»°ç»°ã€‚ä½ æ„è¯†åˆ°ï¼Œä½ æ¥åˆ°äº†ä¸€ä¸ªåä¸ºâ€œæ±‰æœ«ä¸‰å›½â€çš„ä¹±ä¸–ã€‚åœ¨è¿™é‡Œï¼Œæ— è®ºæ˜¯å¸ƒè¡£ç™¾å§“è¿˜æ˜¯è±ªæ°åå£«ï¼Œçš†å¯å‡­å€Ÿæ™ºè°‹ä¸æ­¦å‹‡ï¼Œé€é¹¿ä¸­åŸï¼Œé—®é¼å¤©ä¸‹ï¼Œå¼€åˆ›å±äºè‡ªå·±çš„ç››ä¸–ã€‚ä¸€ä¸ªç¥ç§˜çš„å£°éŸ³åœ¨ä½ è„‘æµ·ä¸­å›å“ï¼šâ€œæ­¤ä¹ƒå¤©å‘½æ‰€å½’ï¼Œäº¦æ˜¯æ±ä¹‹æŠ‰æ‹©ã€‚é€‰æ‹©ä½ çš„å‡ºèº«ï¼Œä¹¦å†™ä½ çš„ä¼ å¥‡å§ã€‚â€';

				// Reset choice buttons
				choicesContainer.innerHTML = `
					<button class="choice-btn" data-choice="orphan">ğŸ“œ ä¹±ä¸–å­¤å„¿ï¼Œèº«ä¸–æµ®æ²‰</button>
					<button class="choice-btn" data-choice="farmer">ğŸŒ¾ ä¹¡é‡å†œå¤«ï¼ŒåŠ›è€•å¤©ä¸‹</button>
					<button class="choice-btn" data-choice="scholar">ğŸ“š è½é­„å£«äººï¼Œæ»¡è…¹ç»çº¶</button>
					<button class="choice-btn" data-choice="merchant">ğŸ’° è¡Œå•†ä¹‹å­ï¼Œè´¢è¿äº¨é€š</button>
				`;

				// Reset scene image
				const initialImagePrompt = "A panoramic view of ancient China during the Three Kingdoms period, with vast plains, rolling hills, a bustling market town, a fortified military camp, and a serene scholarly retreat, traditional Chinese painting style.";
				try {
					await generateImage(initialImagePrompt);
				} catch (error) {
					console.error("Reset image loading failed:", error);
				}

				updateUI();
				alert('æ–°ä¸€å±€ä¹±ä¸–å¾ç¨‹å·²å¼€å¯ï¼');
			}
		}

        // Initialization
        document.addEventListener('DOMContentLoaded', async () => {
            apiUrlInput.value = localStorage.getItem('customApiUrl') || '';
            apiKeyInput.value = localStorage.getItem('customApiKey') || '';
            
            await fetchModels();
            
            choicesContainer.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                    const button = e.target.closest('button');
                    // Only choice text is passed, custom input field is removed
                    handleChoice(button.dataset.choice, button.textContent.trim());
                }
            });

            saveApiBtn.addEventListener('click', saveApiSettings);
            clearApiBtn.addEventListener('click', clearApiSettings);
            
            // Game control button events
            document.getElementById('reset-game-btn').addEventListener('click', resetGame);
            // Revert toggle API settings button to original state (always visible)
            // apiSettingsContainer.classList.toggle('active'); // Original state: always visible if loaded
            toggleApiSettingsBtn.addEventListener('click', () => {
                apiSettingsContainer.classList.toggle('active'); // Toggle visibility
            });
            
            // Check for local file access (Keep this check as it affects the hint text)
            const isLocalFile = window.location.protocol === 'file:';
            
            // Update API settings hint text
            const apiHint = document.getElementById('api-settings-hint');
            if (isLocalFile) {
                apiHint.innerHTML = 'âš ï¸ <strong>æœ¬åœ°æ–‡ä»¶è®¿é—®æ¨¡å¼</strong>ï¼šå¿…é¡»é…ç½®è‡ªå®šä¹‰APIæ‰èƒ½ä½¿ç”¨æ¸¸æˆåŠŸèƒ½ã€‚<br>è¯·å¡«å†™æ‚¨çš„AI APIä¿¡æ¯ï¼ˆé…ç½®ä»…å­˜äºæµè§ˆå™¨æœ¬åœ°ï¼Œå®‰å…¨å¯é ï¼‰ï¼š';
                apiHint.style.color = '#ff6b6b';
                // Update placeholder text
                apiUrlInput.placeholder = 'API URL (å¿…å¡«ï¼Œå¦‚: https://api.openai.com/v1)';
                apiKeyInput.placeholder = 'API Key (å¿…å¡«)';
            }
            
            // Try to load saved game state
            const hasLoadedSave = loadGameState();
            
            if (!hasLoadedSave) {
                // If no saved state, show initial scene
                // showLoading(true); // Always show loading for initial generation
                const initialImagePrompt = "A panoramic view of ancient China during the Three Kingdoms period, with vast plains, rolling hills, a bustling market town, a fortified military camp, and a serene scholarly retreat, traditional Chinese painting style.";
                try {
                    await generateImage(initialImagePrompt);
                } catch (error) {
                    console.error("Initial image loading failed:", error);
                }
            } else {
                // If saved state loaded, but no scene image, generate initial image
                if (!sceneImg.src || sceneImg.src === window.location.href || sceneImg.src.includes('file:///')) {
                    const initialImagePrompt = "A panoramic view of ancient China during the Three Kingdoms period, with vast plains, rolling hills, a bustling market town, a fortified military camp, and a serene scholarly retreat, traditional Chinese painting style.";
                    try {
                        await generateImage(initialImagePrompt);
                    } catch (error) {
                        console.error("Initial image loading failed:", error);
                    }
                }
            }
            
            updateUI();
        });

        // Load Scene - now fully AI-driven
        async function loadScene(sceneKey, playerChoiceText = null) {
            showLoading(true);
            
            try {
                const scene = await generateAdventure(sceneKey, playerChoiceText); // playerCustomAction removed
                if (!scene) {
                    throw new Error('AI failed to generate a valid scene');
                }

                // Check game over state BEFORE updating UI with new scene data
                if (gameState.health <= 0) {
                    // Game is already over, display final message
                    storyText.textContent = scene.text + "\n\nä½ çš„æ°”æ¯é€æ¸å¾®å¼±ï¼Œçœ¼å‰ä¸€é»‘ï¼Œæ„è¯†æ²‰å…¥äº†æ— å°½çš„é»‘æš—... ä½ çš„å†’é™©ç»“æŸäº†ã€‚";
                    choicesContainer.innerHTML = '';
                    const restartBtn = document.createElement('button');
                    restartBtn.className = 'choice-btn';
                    restartBtn.textContent = 'ğŸ”„ é‡æ–°å¼€å§‹';
                    restartBtn.onclick = resetGame;
                    choicesContainer.appendChild(restartBtn);
                    choicesContainer.style.gridTemplateColumns = '1fr';
                    showLoading(false);
                    saveGameState(); // Save game over state
                    return;
                }

                gameState.currentScene = sceneKey;
                storyText.textContent = scene.text;
                renderChoices(scene.choices);
                
                // Wait for image to load before saving game progress
                try {
                    await generateImage(scene.imagePrompt);
                    // Save game progress after all DOM updates (including image)
                    saveGameState();
                } catch (error) {
                    console.error("Image generation failed, but saving game progress:", error);
                    // Even if image fails, save game progress
                    saveGameState();
                }
            } catch (error) {
                console.error("Detailed error for adventure generation:", error);
                showLoading(false);
                
                let errorMessage = error instanceof Error ? error.message : JSON.stringify(error);
                
                // Provide different hints based on error type
                if (errorMessage.includes('timeout') || errorMessage.includes('TIMEOUT')) {
                    alert(`â° è¯·æ±‚è¶…æ—¶ï¼šAIæœåŠ¡å“åº”è¾ƒæ…¢ï¼Œè¯·ç¨åé‡è¯•ã€‚\n\nå»ºè®®ï¼š\n1. æ£€æŸ¥ç½‘ç»œè¿æ¥\n2. ç¨ç­‰ç‰‡åˆ»åé‡æ–°é€‰æ‹©\n3. å¦‚æŒç»­å‡ºç°ï¼Œå¯å°è¯•åˆ·æ–°é¡µé¢`);
                } else if (errorMessage.includes('API key')) {
                    alert(`ğŸ”‘ APIé…ç½®é”™è¯¯ï¼šè¯·æ£€æŸ¥APIå¯†é’¥è®¾ç½®ã€‚\n\nå¦‚æœä½¿ç”¨é»˜è®¤åç«¯APIï¼Œè¯·è”ç³»ç®¡ç†å‘˜ã€‚\nå¦‚æœä½¿ç”¨è‡ªå®šä¹‰APIï¼Œè¯·æ£€æŸ¥APIè®¾ç½®ã€‚`);
                } else if (errorMessage.includes('500') || errorMessage.includes('502') || errorMessage.includes('503')) {
                    alert(`ğŸ”§ æœåŠ¡å™¨é”™è¯¯ï¼šAIæœåŠ¡æš‚æ—¶ä¸å¯ç”¨ã€‚\n\nå»ºè®®ï¼š\n1. ç¨åé‡è¯•\n2. æ£€æŸ¥APIæœåŠ¡çŠ¶æ€\n3. å¦‚æŒç»­å‡ºç°ï¼Œè¯·è”ç³»æŠ€æœ¯æ”¯æŒ`);
                } else if (errorMessage.includes('æœ¬åœ°æ–‡ä»¶è®¿é—®æ¨¡å¼éœ€è¦é…ç½®è‡ªå®šä¹‰API')) {
                    alert(errorMessage); // Display the specific error for local file access
                }
                else {
                    alert(`âŒ å†’é™©ç”Ÿæˆå¤±è´¥: ${errorMessage}\n\nè¯·æ£€æŸ¥ï¼š\n1. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\n2. APIè®¾ç½®æ˜¯å¦æ­£ç¡®\n3. æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°è·å–è¯¦ç»†ä¿¡æ¯`);
                }
            }
        }

        // Generate Adventure using backend API (reverted to original logic)
        async function generateAdventure(currentSceneKey, playerChoiceText) {
            const previousSceneText = storyText.textContent;
            
           const prompt = `ä½ æ˜¯ä¸€ä½é¡¶çº§çš„ä¹±ä¸–æ¼”ä¹‰å™äº‹å¤§å¸ˆï¼Œè´Ÿè´£åŠ¨æ€ç”Ÿæˆä¸€ä¸ªè¿è´¯ã€æœ‰è¶£ä¸”èŠ‚å¥åˆç†çš„ä¸‰å›½æ•…äº‹ã€‚

**æ ¸å¿ƒåŸåˆ™ä¸å¾ªç¯æ‰“ç ´ (æœ€é«˜ä¼˜å…ˆçº§è§„åˆ™):**
1.  **äº‹ä»¶é©±åŠ¨å™äº‹:** ä¸“æ³¨äºæè¿°å…·ä½“å‘ç”Ÿçš„æˆ˜å½¹ã€äººç‰©å¯¹è¯å’Œå±€åŠ¿å˜åŒ–ã€‚
2.  **å‰§æƒ…æ·±åº¦ä¼˜å…ˆ:** ä¼˜å…ˆæ·±åŒ–å½“å‰äº‹ä»¶å’Œå·²æœ‰æ­¦å°†è°‹å£«å…³ç³»ï¼Œè€Œéè½»æ˜“å¼•å…¥æ–°è§’è‰²ã€‚
3.  **è‡ªç„¶æ•´åˆ:** å°†ç©å®¶çš„**æˆ˜æ³•/è®¡ç­–** (${gameState.skills.map(s => s.name).join('ã€') || 'æ— '}) å’Œ**è¡Œå›Šç‰©å“** (${gameState.items.map(i => i.name).join('ã€') || 'æ— '}) è‡ªç„¶åœ°èå…¥äº‹ä»¶æè¿°å’Œé€‰æ‹©ä¸­ã€‚
4.  **ç»“å°¾å³æ‚¬å¿µ:** å‰§æƒ…å¿…é¡»åœ¨äº‹ä»¶çš„å…³é”®è½¬æŠ˜ç‚¹æˆ–é«˜æ½®æ—¶åœæ­¢ï¼Œä¸å¸¦ä»»ä½•å¼•å¯¼è¯­ã€‚
5.  **å¾ªç¯æ‰“ç ´ (LOOP BREAKER):**
    * **åˆ†æ**æœ€æ–°çš„5æ¡**å¤§äº‹è®°**ã€‚
    * **è¯†åˆ«**é‡å¤äº‹ä»¶ï¼ˆå¦‚ï¼šä¸åŒä¸€æ•Œå°†ç¼ æ–—ï¼Œæˆ–ä¹…æ”»åŒä¸€åŸæ± ä¸ä¸‹ï¼‰ã€‚
    * **å¼ºåˆ¶ç»“æŸ**å½“å‰å¾ªç¯äº‹ä»¶ã€‚
        * **æˆ˜æ–—åƒµæŒ:** æ•Œå°†å¿…é¡»è¢«å‡»è´¥ã€æ’¤é€€æˆ–å› çªå‘äº‹ä»¶è€Œç»ˆç»“ã€‚
        * **æ”»åŸ/å›´å›°:** åŸæ± å¿…é¡»è¢«æ”»å…‹ã€å‘ç°çªç ´å£ã€æˆ–é­é‡æ— æ³•é€¾è¶Šçš„é˜»ç¢ã€‚
    * **æä¾›æ–°é€‰æ‹©:** æä¾›çš„é€‰é¡¹å¿…é¡»æ˜¯äº‹ä»¶ç»“æŸåçš„æ–°è¡ŒåŠ¨ï¼ˆå¦‚â€œæ¸…ç‚¹æˆ˜æœâ€ã€â€œæ•´é¡¿å…µé©¬â€ã€â€œæ’¤ç¦»æ­¤åœ°â€ï¼‰ï¼Œç»ä¸èƒ½æ˜¯ç»§ç»­å¾ªç¯çš„é€‰é¡¹ï¼ˆå¦‚â€œå†æ¬¡å†²é”‹â€ã€â€œç»§ç»­å›´å›°â€ï¼‰ã€‚

**å‰§æƒ…èŠ‚å¥ä¸æ—¶é—´æµé€:**
1.  **æ„ŸçŸ¥å›åˆ:** å½“å‰æ˜¯æ¸¸æˆç¬¬ **${gameState.turn} å›åˆ**ï¼ˆç›¸å½“äºä¸€å¹´ï¼‰ã€‚
2.  **é¿å…æ‹–æ²“:** ä¸€ä¸ªæ ¸å¿ƒæˆ˜å½¹æˆ–è®¡è°‹ä¸åº”æŒç»­è¶…è¿‡10ä¸ªå›åˆã€‚

**å†…å®¹é™åˆ¶:**
1.  **ä¸¥ç¦å¼•å¯¼è¯­**æˆ–**æ€»ç»“æ€§è¯´æ•™**ã€‚
2.  **åªæä¾›æ¸¸æˆå†…å®¹æè¿°**ï¼Œä¸è¿›è¡Œé¢å¤–è§£é‡Šæˆ–æŒ‡ä»¤ï¼Œé™¤éæ˜ç¡®è¦æ±‚ã€‚

**ç©å®¶å½“å‰çŠ¶æ€:**
-   **èº«ä»½:** ç­‰çº§ ${gameState.level} (ä¾‹å¦‚ï¼šå¸ƒè¡£ï¼Œå¿å°‰ï¼Œåå°†å†›ï¼Œéƒ¡å®ˆï¼Œå·ç‰§ï¼Œå¤§å°†å†›ï¼Œä¸ç›¸ï¼Œå¸ç‹)
-   **å±æ€§:** **ä½“åŠ›** ${gameState.health}/${gameState.maxHealth}ï¼Œ**é“œé’±** ${gameState.coins}ï¼Œ**å£°æœ›** ${gameState.reputation}
-   **æœ€è¿‘çš„å¤§äº‹è®°:** ${gameState.adventureLog.slice(-5).map(log => `å›åˆ ${log.turn}: ${log.entry}`).join('; ') || 'æ— '}
-   **å‰æƒ…æè¦:** "${previousSceneText.slice(-250)}"
-   **ç©å®¶é€‰æ‹©çš„è¡ŒåŠ¨:** "${playerChoiceText}"

**è¾“å‡ºè§„èŒƒ (ä¸¥æ ¼éµå®ˆJSONæ ¼å¼ï¼Œæ‰€æœ‰æ•°å€¼å¿…é¡»æ˜¯æ•°å­—):**
{
  "text": "çº¯ç²¹çš„äº‹ä»¶æè¿°(150-300å­—)ã€‚ç»“å°¾å¿…é¡»æ˜¯ä¸€ä¸ªå…·ä½“çš„é«˜æ½®æˆ–è½¬æŠ˜ç”»é¢ã€‚",
  "imagePrompt": "Traditional Chinese painting, Three Kingdoms period, [ä¸'text'å†…å®¹é«˜åº¦ç›¸å…³çš„å…·ä½“åœºæ™¯ã€äººç‰©ã€åŠ¨ä½œå…³é”®è¯]",
  "choices": [
    {"text": "ç¬¦åˆå½“å‰æƒ…æ™¯çš„è¡ŒåŠ¨1", "target": "action_1"},
    {"text": "åŸºäºç©å®¶æˆ˜æ³•æˆ–è®¡ç­–çš„è¡ŒåŠ¨2", "target": "action_2"},
    {"text": "å¯èƒ½æ”¹å˜å½“å‰å±€åŠ¿çš„å†’é™©è¡ŒåŠ¨3", "target": "action_3"}
  ],
  "gameStateUpdates": {
    "health": -10, // ä½“åŠ›å˜åŒ–
    "coins": 50,   // é“œé’±å˜åŒ–
    "reputation": 1, // å£°æœ›å˜åŒ–
    "level": 0     // èº«ä»½å˜åŒ–
  },
  "itemUpdates": {"add": ["è·å¾—çš„ç‰©å“å"], "remove": ["æ¶ˆè€—çš„ç‰©å“ID"]}, // å…µå™¨ï¼Œé©¬åŒ¹ï¼Œç²®é£Ÿï¼Œå®ç‰©ç­‰
  "unlockAchievements": ["éœ€è¦è§£é”çš„åŠŸç»©ID"],
  "logEntry": "å¯¹æœ¬æ¬¡äº‹ä»¶çš„é«˜åº¦æ¦‚æ‹¬ï¼ˆ20å­—ä»¥å†…ï¼‰"
}
`;

            let response;
            // Original logic: always use backend API
            response = await fetch('/api/chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt: prompt,
                    model: localStorage.getItem('customModel') || '' // Still allow model override if set
                })
            });

            if (!response.ok) {
                throw new Error(`API Request Failed: ${response.status} ${await response.text()}`);
            }

            const data = await response.json();
            console.log("Raw data from API:", data);
            
            // Add detailed debug info
            if (data.usage) {
                console.log("Token usage:", data.usage);
                if (data.usage.completion_tokens >= 3900) {
                    console.warn("Warning: Response near token limit, might be truncated");
                }
            }
            
            if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                throw new Error('API returned malformed data: missing choices or message field');
            }
            
            let contentString = data.choices[0].message.content;
            console.log("AI Raw content:", contentString);
            
            if (!contentString || contentString.trim() === '') {
                throw new Error('AI returned empty content');
            }
            
            // Attempt to extract JSON code block
            const match = contentString.match(/```json\s*([\s\S]*?)\s*```/);
            if (match) {
                contentString = match[1];
                console.log("Extracted JSON content:", contentString);
            }

            // Try to fix incomplete JSON
            function tryFixIncompleteJson(jsonStr) {
                jsonStr = jsonStr.trim();
                
                // Attempt to find the last valid JSON character ('}' or ']' or '"')
                const lastBrace = jsonStr.lastIndexOf('}');
                const lastBracket = jsonStr.lastIndexOf(']');
                const lastQuote = jsonStr.lastIndexOf('"');
                const lastNumber = jsonStr.search(/[0-9]\s*$/);

                const lastValidCharIndex = Math.max(lastBrace, lastBracket, lastQuote, lastQuote !== -1 ? jsonStr.lastIndexOf('"', lastQuote - 1) : -1, lastNumber); // Also consider previous quote for string truncation

                // If string has content after the last valid character, it might be truncated
                if (lastValidCharIndex !== -1 && lastValidCharIndex < jsonStr.length - 1) {
                    jsonStr = jsonStr.substring(0, lastValidCharIndex + 1);
                }
                
                // Re-calculate bracket and brace balance
                let openBraces = (jsonStr.match(/{/g) || []).length;
                let closeBraces = (jsonStr.match(/}/g) || []).length;
                let openBrackets = (jsonStr.match(/\[/g) || []).length;
                let closeBrackets = (jsonStr.match(/\]/g) || []).length;

                // Close unclosed brackets
                while (openBrackets > closeBrackets) {
                    jsonStr += ']';
                    closeBrackets++;
                }
                
                // Close unclosed braces
                while (openBraces > closeBraces) {
                    jsonStr += '}';
                    closeBraces++;
                }

                return jsonStr;
            }

            try {
                let content;
                try {
                    content = JSON.parse(contentString);
                } catch (firstError) {
                    console.log("First JSON parse failed, attempting fix:", firstError.message);
                    const fixedJsonString = tryFixIncompleteJson(contentString);
                    console.log("Fixed JSON:", fixedJsonString);
                    content = JSON.parse(fixedJsonString);
                    console.log("Fix successful!");
                }
                console.log("Successfully parsed content:", JSON.stringify(content, null, 2));
                
                // Validate required fields
                if (!content.text) {
                    console.warn("Warning: Missing text field, using default");
                    content.text = "ä½ ç»§ç»­åœ¨è¿™ä¸ªç¥ç§˜çš„ä¸–ç•Œä¸­æ¢ç´¢...";
                }
                if (!content.imagePrompt) {
                    console.warn("Warning: Missing imagePrompt field, using default");
                    content.imagePrompt = "A traditional Chinese painting, ancient battlefield scene";
                }
                if (!content.choices || !Array.isArray(content.choices)) {
                    console.warn("Warning: Missing choices field, using default");
                    content.choices = [
                        { text: "ç»§ç»­æ¢ç´¢", target: "continue" },
                        { text: "ä¼‘æ¯ç‰‡åˆ»", target: "rest" }
                    ];
                }
                if (!content.gameStateUpdates) {
                    content.gameStateUpdates = {};
                }
                if (!content.itemUpdates) {
                    content.itemUpdates = { add: [], remove: [] };
                }
                if (!content.unlockAchievements) {
                    content.unlockAchievements = [];
                }
                if (!content.logEntry) {
                    content.logEntry = "ç»§ç»­å†’é™©...";
                }

                if (content.gameStateUpdates) {
                    const updates = content.gameStateUpdates;
                    ['health', 'maxHealth', 'attack', 'defense', 'agility', 'charm', 'coins', 'reputation', 'level'].forEach(key => {
                        if (updates[key] !== undefined && typeof gameState[key] === 'number') {
                            gameState[key] += Number(updates[key]);
                        }
                    });
                    if (gameState.health < 0) gameState.health = 0;
                    if (gameState.health > gameState.maxHealth) gameState.health = gameState.maxHealth;
                    
                    if (updates.skills && Array.isArray(updates.skills)) {
                        updates.skills.forEach(skillName => {
                            if (!gameState.skills.find(s => s.name === skillName)) {
                                gameState.skills.push({
                                    name: skillName,
                                    description: "å†’é™©ä¸­ä¹ å¾—çš„æŠ€èƒ½",
                                    icon: "fa-solid fa-star" // Default icon for newly learned skills
                                });
                            }
                        });
                    }
                }

                if (content.itemUpdates) {
                    if (content.itemUpdates.add && Array.isArray(content.itemUpdates.add)) {
                        content.itemUpdates.add.forEach(newItemName => {
                            if (typeof newItemName === 'string') {
                                gameState.items.push({ id: newItemName.toLowerCase().replace(/\s/g, '_'), name: newItemName });
                            }
                        });
                    }
                    if (content.itemUpdates.remove) {
                        content.itemUpdates.remove.forEach(itemIdToRemove => {
                            gameState.items = gameState.items.filter(item => item.id !== itemIdToRemove);
                        });
                    }
                }

                if (content.unlockAchievements && Array.isArray(content.unlockAchievements)) {
                    content.unlockAchievements.forEach(achIdToUnlock => {
                        const achievement = gameState.achievements.find(a => a.id === achIdToUnlock);
                        if (achievement && !achievement.unlocked) {
                            achievement.unlocked = true;
                        }
                    });
                }
                
                // Automatically check for skill-related achievements
                const skillCount = gameState.skills.length;
                if (skillCount >= 1) {
                    const firstSkillAch = gameState.achievements.find(a => a.id === 'first_skill');
                    if (firstSkillAch && !firstSkillAch.unlocked) {
                        firstSkillAch.unlocked = true;
                        console.log("Unlocked achievement: åˆçª¥é—¨å¾„");
                    }
                }
                if (skillCount >= 5) {
                    const skillMasterAch = gameState.achievements.find(a => a.id === 'skill_master');
                    if (skillMasterAch && !skillMasterAch.unlocked) {
                        skillMasterAch.unlocked = true;
                        console.log("Unlocked achievement: æŠ€è‰ºç²¾æ¹›");
                    }
                }
                
                // Check for spell-like skills count
                const spellSkills = gameState.skills.filter(skill =>
                    skill.name.includes('æœ¯') || skill.name.includes('æ³•') || skill.name.includes('å’’')
                );
                if (spellSkills.length >= 3) {
                    const spellCasterAch = gameState.achievements.find(a => a.id === 'spell_caster');
                    if (spellCasterAch && !spellCasterAch.unlocked) {
                        spellCasterAch.unlocked = true;
                        console.log("Unlocked achievement: æ³•æœ¯å¤§å¸ˆ");
                    }
                }
                
                if(content.logEntry && typeof content.logEntry === 'string') {
                    gameState.turn++;
                    gameState.adventureLog.push({ turn: gameState.turn, entry: content.logEntry });
                }

                updateUI();
                
                return content;
            } catch (e) {
                console.error("JSON parse failed:", e);
                console.error("Content that failed to parse:", contentString);
                
                // Attempt to extract text info from raw content
                let extractedText = "æŠ±æ­‰ï¼ŒAIå“åº”è§£æå¤±è´¥ã€‚ä½ å‘ç°è‡ªå·±ç«™åœ¨ä¸€ä¸ªç¥ç§˜çš„åœ°æ–¹ï¼Œå‘¨å›´äº‘é›¾ç¼­ç»•ï¼Œä¼¼ä¹æœ‰æ— æ•°çš„å¯èƒ½æ€§ç­‰å¾…ç€ä½ å»æ¢ç´¢ã€‚";
                
                // Try to extract text field from truncated JSON
                const textMatch = contentString.match(/"text":\s*"([^"]*(?:\\.[^"]*)*)/);
                if (textMatch && textMatch[1]) {
                    extractedText = textMatch[1].replace(/\\"/g, '"').replace(/\n/g, '\n');
                    console.log("Extracted text from truncated JSON:", extractedText);
                }
                
                // If JSON parsing fails, generate a smart fallback response
                const fallbackContent = {
                    text: extractedText,
                    imagePrompt: "A traditional Chinese painting, ancient landscape with mist",
                    choices: [
                        { text: "ğŸ”„ é‡æ–°å°è¯•", target: "retry" },
                        { text: "ğŸ  è¿”å›èµ·ç‚¹", target: "start" },
                        { text: "ç»§ç»­æ¢ç´¢", target: "continue" }
                    ],
                    gameStateUpdates: {},
                    itemUpdates: { add: [], remove: [] },
                    unlockAchievements: [],
                    logEntry: "é‡åˆ°äº†ä¸€äº›æŠ€æœ¯é—®é¢˜ï¼Œä½†å†’é™©ä»åœ¨ç»§ç»­..."
                };
                
                console.log("Using fallback response:", fallbackContent);
                return fallbackContent;
            }
        }

        async function generateImage(prompt) {
            return new Promise(async (resolve, reject) => {
                try {
                    showLoading(true); // Ensure loading is shown for image generation
                    sceneImg.style.opacity = 0.5;
                    
                    let imageUrl;
                    // Original logic: Always use backend API for image generation
                    const response = await fetch('/api/image', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            prompt: prompt,
                            width: 800,
                            height: 600,
                            nologo: true,
                            model: 'flux'
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Image generation API request failed: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    if (!data.success || !data.imageUrl) {
                        throw new Error('Image generation failed');
                    }
                    
                    imageUrl = data.imageUrl;
                    console.log('Image generated successfully:', data);
                    
                    // Preload image
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    
                    img.onload = () => {
                        sceneImg.src = imageUrl;
                        sceneImg.style.opacity = 1;
                        showLoading(false);
                        resolve(imageUrl);
                    };
                    
                    img.onerror = () => {
                        console.error("Image loading failed, using fallback image");
                        // Use fallback image URL
                        const fallbackUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMWExYTJlIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIyNCIgZmlsbD0iIzRlY2RjNCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPuS/ruS7meS4lueVjO+8muS6kea4uuS7meWcnzwvdGV4dD4KPC9zdmc+';
                        sceneImg.src = fallbackUrl;
                        sceneImg.style.opacity = 1;
                        showLoading(false);
                        resolve(fallbackUrl);
                    };
                    
                    img.src = imageUrl;
                    
                } catch (error) {
                    console.error('Image generation error:', error);
                    // Use fallback image
                    const fallbackUrl = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iODAwIiBoZWlnaHQ9IjYwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMWExYTJlIi8+CiAgPHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIyNCIgZmlsbD0iIzRlY2RjNCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPuS/ruS7meS4lueVjO+8muS6kea4uuS7meWcnzwvdGV4dD4KPC9zdmc+';
                    sceneImg.src = fallbackUrl;
                    sceneImg.style.opacity = 1;
                    showLoading(false);
                    reject(error); // Reject the promise to propagate the error
                }
            });
        }
        
        function renderChoices(choices) {
            choicesContainer.innerHTML = '';
            if (!choices || choices.length === 0) {
                const endButton = document.createElement('button');
                endButton.className = 'choice-btn';
                endButton.textContent = 'æœ¬æ¬¡å†’é™©æš‚å‘Šä¸€æ®µè½ï¼Œåˆ·æ–°é¡µé¢é‡æ–°å¼€å§‹ã€‚';
                endButton.onclick = () => window.location.reload();
                choicesContainer.appendChild(endButton);
                return;
            }
            choices.forEach(choice => {
                const button = document.createElement('button');
                button.className = 'choice-btn';
                button.dataset.choice = choice.target;
                button.textContent = choice.text;
                choicesContainer.appendChild(button);
            });
        }
        
        function handleChoice(choiceTarget, choiceText) {
            const firstChoiceAch = gameState.achievements.find(a => a.id === 'first_choice');
            if (firstChoiceAch && !firstChoiceAch.unlocked) {
                firstChoiceAch.unlocked = true;
            }
            loadScene(choiceTarget, choiceText); 
        }

        function showLoading(show) {
            loadingOverlay.classList.toggle('active', show);
        }

		function updateUI() {
			if (!Array.isArray(gameState.adventureLog)) {
				gameState.adventureLog = [];
			}

			healthBar.style.width = `${(gameState.health / gameState.maxHealth) * 100}%`;
			healthText.textContent = `ä½“åŠ›: ${gameState.health}/${gameState.maxHealth}`;
			coinsEl.textContent = gameState.coins;
			reputationEl.textContent = gameState.reputation;

			// Update identity/status display based on level
			if (gameState.level >= 30) {
				levelEl.textContent = 'å¸ç‹';
			} else if (gameState.level >= 25) {
				levelEl.textContent = 'ä¸ç›¸/å¤§å°†å†›';
			} else if (gameState.level >= 20) {
				levelEl.textContent = 'å·ç‰§/å¤ªå®ˆ';
			} else if (gameState.level >= 15) {
				levelEl.textContent = 'éƒ¡å®ˆ/åˆºå²';
			} else if (gameState.level >= 10) {
				levelEl.textContent = 'æ ¡å°‰/éƒ½å°‰';
			} else if (gameState.level >= 5) {
				levelEl.textContent = 'å¿ä»¤/äº­é•¿';
			} else if (gameState.level > 1) {
				levelEl.textContent = 'ä¹¡ç»…/é‡Œæ­£';
			} else {
				levelEl.textContent = 'å¸ƒè¡£';
			}
			levelEl.title = `ç­‰çº§: ${gameState.level}`;

			attackEl.textContent = gameState.attack;
			defenseEl.textContent = gameState.defense;
			agilityEl.textContent = gameState.agility;
			charmEl.textContent = gameState.charm;

			skillsList.innerHTML = '';
			if (!gameState.skills || gameState.skills.length === 0) {
				skillsList.innerHTML = '<div>å°šæœªä¹ å¾—ä»»ä½•æˆ˜æ³•æˆ–è®¡ç­–</div>';
			} else {
				gameState.skills.forEach(skill => {
					const skillItem = document.createElement('div');
					skillItem.className = 'skill-item';
					skillItem.innerHTML = `<div class="skill-name"><i class="${skill.icon || 'fa-solid fa-book'}"></i> ${skill.name}</div><div class="skill-description">${skill.description}</div>`;
					skillsList.appendChild(skillItem);
				});
			}

			itemsGrid.innerHTML = '';
			if (!gameState.items || gameState.items.length === 0) {
				itemsGrid.innerHTML = '<div>è¡Œå›Šç©ºç©º...</div>';
			} else {
				gameState.items.forEach(item => {
					const itemEl = document.createElement('div');
					itemEl.className = 'item-text';
					itemEl.textContent = `â€¢ ${item.name}`;
					itemsGrid.appendChild(itemEl);
				});
			}

			achievementList.innerHTML = '';
			const unlockedAchievements = gameState.achievements.filter(a => a.unlocked);
			if (unlockedAchievements.length === 0) {
				achievementList.innerHTML = '<div>å°šæ— åŠŸç»©å¯è¨€</div>';
			} else {
				unlockedAchievements.forEach(ach => {
					const achEl = document.createElement('div');
					achEl.className = 'achievement-text';
					achEl.innerHTML = `â€¢ <i class="fa-solid fa-trophy"></i> ${ach.text}`; // Added a trophy icon for achievements
					achievementList.appendChild(achEl);
				});
			}

			adventureLogEl.innerHTML = '';
			if (!gameState.adventureLog || gameState.adventureLog.length === 0) {
				adventureLogEl.innerHTML = '<div>å¤©ä¸‹å¤§äº‹ï¼Œç”±ä½ ä¹¦å†™...</div>';
			} else {
				gameState.adventureLog.slice().reverse().forEach(log => {
					const logEl = document.createElement('div');
					logEl.className = 'log-entry';
					logEl.innerHTML = `<span class="log-turn">[å›åˆ ${log.turn}]</span> ${log.entry}`;
					adventureLogEl.appendChild(logEl);
				});
			}
		}
        
        async function fetchModels() {
            const modelSelect = document.getElementById('model-input');
            modelSelect.innerHTML = '<option value="">åŠ è½½ä¸­...</option>';
            
            try {
                let defaultModelName = 'DeepSeek-R1-0528';
                
                // Always try to get backend config (original logic)
                try {
                    const configResponse = await fetch('/api/config');
                    if (configResponse.ok) {
                        const config = await configResponse.json();
                        defaultModelName = config.defaultModel;
                    }
                } catch (e) {
                    console.log('Could not fetch backend config, using default values');
                }
                
                // Always use backend API to fetch models (original logic)
                const response = await fetch('/api/models');

                if (!response.ok) {
                    throw new Error(`Failed to fetch model list: ${response.status}`);
                }

                const data = await response.json();
                const models = data.data
                    .filter(model => model.id)
                    .sort((a, b) => a.id.localeCompare(b.id));

                // Add default option
                let optionsHtml = `<option value="">ä½¿ç”¨åç«¯é»˜è®¤æ¨¡å‹ (${defaultModelName})</option>`;
                optionsHtml += models
                    .map(model => `<option value="${model.id}">${model.id}</option>`)
                    .join('');
                
                modelSelect.innerHTML = optionsHtml;
                
                const savedModel = localStorage.getItem('customModel');
                if (savedModel !== null && (savedModel === '' || models.some(m => m.id === savedModel))) {
                    modelSelect.value = savedModel;
                }
            } catch (error) {
                console.error('Failed to fetch model list:', error);
                modelSelect.innerHTML = `<option value="">ä½¿ç”¨åç«¯é»˜è®¤æ¨¡å‹ (${defaultModelName})</option><option value="DeepSeek-R1-0528">DeepSeek-R1-0528</option>`;
            }
        }

        function saveApiSettings() {
            localStorage.setItem('customApiUrl', apiUrlInput.value);
            localStorage.setItem('customModel', modelInput.value);
            localStorage.setItem('customApiKey', apiKeyInput.value);
            fetchModels();
            alert('APIè®¾ç½®å·²ä¿å­˜!');
        }

        function clearApiSettings() {
            localStorage.removeItem('customApiUrl');
            localStorage.removeItem('customModel');
            localStorage.removeItem('customApiKey');
            apiUrlInput.value = '';
            modelInput.value = '';
            apiKeyInput.value = '';
            alert('APIè®¾ç½®å·²æ¸…é™¤!');
        }
    </script>
</body>
</html>